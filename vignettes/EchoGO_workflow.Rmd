---
title: "EchoGO Workflow: from inputs to consensus"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{EchoGO Workflow: from inputs to consensus}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse   = TRUE,
  comment    = "#>",
  fig.width  = 7,
  fig.height = 4.5,
  error      = TRUE
)

RUN_HEAVY <- identical(Sys.getenv("NOT_CRAN"), "true")

suppressPackageStartupMessages({
  library(EchoGO)
  library(readxl)
  library(dplyr)
})
```

# Before you start: what goes into `input/`

EchoGO supports **two input layouts**:

## 1) Classic / de novo transcriptome layout (Trinity + Trinotate + GOseq)

This is the original EchoGO workflow. It assumes you have already run a **Trinity ‚Üí Trinotate ‚Üí GOseq**
pipeline (or an equivalent RNA-seq workflow) and that you have:

- a **count matrix** (e.g. Trinity/edgeR/DESeq2 output),
- one or more **differential expression (DE) tables**, and
- a **Trinotate report** with functional annotation and GO terms.

A typical Trinity/Trinotate/GOseq pipeline is documented at:

<https://github.com/trinityrnaseq/trinityrnaseq/wiki>

EchoGO does **not** run Trinity or Trinotate for you. Instead, it takes their outputs (plus GOseq results
if you generated them) and performs:

- cross-species enrichment via g:Profiler,
- strict and exploratory consensus scoring,
- semantic reduction with RRvGO, and
- GO term network analysis.

## 2) Reference-based RNA-seq layout (DESeq2 + GOseq precomputed)

EchoGO can also run from a **reference-based experiment folder** where GOseq has already been computed.
A typical contrast input directory contains:

A reference-based EchoGO input directory typically contains:

- `allcounts_table.txt`  (count matrix; required by the current input resolver)
- `dge_<CONTRAST>.csv`   (DESeq2 results; one per contrast)
- `dge_<CONTRAST>.GOseq.enriched.tsv`  (GOseq enriched categories)
- `dge_<CONTRAST>.GOseq.depleted.tsv`  (optional; only if depleted terms exist)
- `Trinotate_for_EchoGO.tsv`  (minimal ‚ÄúTrinotate-like‚Äù table used by EchoGO)
- `<reference_label>_eggNOG_for_EchoGO.tsv` (species-labeled eggNOG table used by EchoGO)


In this mode, GOseq `gene_ids` may already be gene symbols/names rather than transcript IDs. If GOseq
`gene_ids` do not match the annotation `transcript_id`, EchoGO treats them as already-usable names
(intended behavior for reference-based pipelines).

To generate this complete reference-based input bundle (including the external eggNOG-mapper step),
follow the repository guide:

- `doc/reference-based-inputs.md`

When you use `echogo_scaffold("my_project")`, the `input/_README.txt` explains both layouts and the
expected filenames.

------------------------------------------------------------------------

# Welcome to EchoGO

```         
        ><(((¬∫>  üß¨   E   c   h   o   G   O   üß¨  <¬∫)))><

üêô ü¶ã üê∏ üêü Cross-Species Consensus Enrichment ü¶ê üêç ü¶â ü¶á
```

EchoGO is your all-in-one toolkit for robust, multi-species functional enrichment analysis. Whether you're working with transcriptomes, proteomes, or ranked gene lists from model organisms or de novo assemblies, EchoGO integrates bias-corrected enrichment (GOseq), cross-species orthology (g:Profiler), semantic reduction (RRvGO), and network analysis into a single, reproducible workflow.

**This vignette covers:**

-   Installing and configuring EchoGO\
-   Setting up your data and choosing species\
-   Running the full end-to-end pipeline\
-   Understanding the output structure\
-   Exploring results with minimal working examples

For detailed interpretation of outputs, consensus scores, RRvGO, and networks, see `vignette("EchoGO_interpretation")`.

------------------------------------------------------------------------

# Quick orientation

## Load EchoGO and check your setup

```{r quick_start}
# See the welcome message with defaults and helper functions
echogo_help()
```

This prints helpful information about default OrgDb, species, and key functions. You can silence the startup message with:

```{r, eval=FALSE}
suppressPackageStartupMessages(library(EchoGO))
```

## Access demo data and results

EchoGO ships with frozen demo inputs and outputs so you can explore without re-running the full pipeline:

```{r demo_paths}
demo_in  <- echogo_demo_path()          # Location of demo inputs
demo_out <- echogo_demo_results_path()  # Location of frozen demo results

cat("Demo input path:\n", demo_in, "\n\n")
cat("Demo output path:\n", demo_out, "\n")
```

Open these in your file manager:

```{r, eval=FALSE}
echogo_open_demo()  # Opens demo input/results and lists key files
```

------------------------------------------------------------------------

# Configuring EchoGO

## Default OrgDb and species

EchoGO uses global options to set defaults:

```{r show_defaults}
# Check current defaults
default_orgdb <- getOption("EchoGO.default_orgdb", "org.Mm.eg.db")
default_species <- getOption(
  "EchoGO.default_species",
  c("hsapiens", "mmusculus", "drerio",
    "btaurus", "rnorvegicus",
    "dmelanogaster", "ggallus")
)

cat("Default OrgDb:", default_orgdb, "\n")
cat("Default species:", paste(default_species, collapse = ", "), "\n")
```

### Changing defaults

```{r, eval=FALSE}
# Use human genome + fewer species for a quick run
options(EchoGO.default_orgdb   = "org.Hs.eg.db")
options(EchoGO.default_species = c("hsapiens", "mmusculus", "drerio"))
```

### Listing available OrgDb packages

```{r list_orgdb}
# Check which OrgDb packages are installed
echogo_list_orgdb()
```

If you need to install an OrgDb package:

```{r, eval=FALSE}
# Get installation instructions (BiocManager::install commands)
echogo_install_orgdb_instructions()

# Or let EchoGO install it automatically
echogo_install_orgdb(orgdb = "org.Hs.eg.db")

# Ensure OrgDb is available before running
echogo_require_orgdb(orgdb = "org.Mm.eg.db")
```

------------------------------------------------------------------------

# Choosing species

## Interactive species picker

The easiest way to choose species is the interactive picker:

```{r, eval=FALSE}
echogo_pick_species()
```

This opens an interactive table where you can:

-   Browse the full g:Profiler organism list\
-   Filter by taxonomy (e.g., "Mammals", "Fish", "Invertebrates")\
-   Select and copy organism IDs\
-   Validate your choices

## Validating species codes

Before running the full pipeline, validate your species choices:

```{r, eval=FALSE}
my_species <- c("hsapiens", "mmusculus", "drerio")

# Check if all species are recognized by g:Profiler
echogo_preflight_species(my_species)
```

If any species codes are invalid, you'll get suggestions for similar names.

## Common organism codes

```         
Vertebrates:
  hsapiens       - Human
  mmusculus      - Mouse
  drerio         - Zebrafish
  ggallus        - Chicken
  btaurus        - Cattle
  rnorvegicus    - Rat

Invertebrates:
  dmelanogaster  - Fruit fly
  celegans       - C. elegans

For the full list, visit:
https://biit.cs.ut.ee/gprofiler/page/organism-list
```

------------------------------------------------------------------------

# Running the pipeline

You have three main ways to run EchoGO:

1.  **Quick demo** with built-in data (`echogo_quickstart()`)\
2.  **Scaffold-based run** using `echogo_scaffold()` + `echogo_run()`\
3.  **Low-level control** with `run_full_echogo()`

## Option 1: Quick start with demo data

The fastest way to see how EchoGO works is the demo:

```{r quickstart_demo, eval=RUN_HEAVY}
# Run the built-in demo (small subset, 3 species + default OrgDb)
echogo_quickstart(run_demo = TRUE)
```

This runs on a small subset using the default configuration and produces a complete set of outputs in the demo results directory.

## Option 2: Create a project scaffold

For your own data:

```{r, eval=FALSE}
# Create a new project directory with input/output structure
echogo_scaffold("my_project")
```

This creates:

```         
my_project/
  ‚îú‚îÄ‚îÄ input/
  ‚îÇ   ‚îú‚îÄ‚îÄ _README.txt          (Instructions for input files)
  ‚îÇ   ‚îî‚îÄ‚îÄ ...                  (GOseq, DE, annotation files, counts matrix)
  ‚îî‚îÄ‚îÄ results/                 (Will be created after run)
```

The exact expected inputs are described in `input/_README.txt`. In the **Trinity/Trinotate/GOseq** mode, the core files are:

-   `gene.counts.matrix.tsv` ‚Äì gene-level count matrix (ID + sample columns)\
-   `DE_*.tsv` ‚Äì one or more DE result tables with at least `id`, `log2FC`, `pvalue`, `padj`\
-   `Trinotate.xls` ‚Äì standard Trinotate report with GO terms and KEGG IDs

EchoGO reads these files, matches IDs across them, and uses Trinotate GO/KEGG annotations as the basis for GOseq and cross-species enrichment.

## Option 3a: Run the scaffolded workflow with `echogo_run()`

Once your input is ready:

```{r, eval=FALSE}
echogo_run(
  input_dir = "my_project/input",
  outdir    = "my_project/results"
)
```

`echogo_run()` is a convenience wrapper that:

-   Respects your `EchoGO.default_species` and `EchoGO.default_orgdb` options\
-   Infers which inputs are present (GOseq, DE, annotations, counts)\
-   Calls `run_full_echogo()` with reasonable defaults

## Option 3b: Run the full workflow explicitly

If you want full control, call `run_full_echogo()` directly:

```{r, eval=FALSE}
run_full_echogo(
  input_dir   = "my_project/input",
  species     = c("hsapiens", "mmusculus", "drerio"),
  orgdb       = "org.Hs.eg.db",
  outdir      = "my_project/results",
  make_report = TRUE
)
```

## Option 3c: Reference-based RNA-seq run (DESeq2 + GOseq precomputed)

If your input directory already contains precomputed GOseq enrichment tables and the minimal
Trinotate-like + eggNOG annotation tables (reference-based workflow), you can run EchoGO directly
from that folder.

If you need to generate those inputs from a reference genome (GFF3 + protein FASTA), see:

- `doc/reference-based-inputs.md`

```{r, eval=FALSE}
input_dir <- "E:/.../dge_RRf_BBf/input"
outdir    <- "E:/.../dge_RRf_BBf/results"

fish_species <- c(
  "drerio", "strutta", "gaculeatus", "olatipes", "trubripes", "amexicanus",
  "oniloticus", "ssalar", "omykiss", "okisutch", "otshawytscha"
)

res <- run_full_echogo(
  input_dir              = input_dir,
  species                = fish_species,
  orgdb                  = "org.Dr.eg.db",
  outdir                 = outdir,
  strict_only            = FALSE,
  run_evaluation         = TRUE,
  use_trinotate_universe = TRUE,
  make_report            = TRUE,
  verbose                = TRUE
)
```

### Key parameters

-   **`input_dir`** ‚Äì path containing your input files (see `_README.txt` in the scaffold).\
-   **`species`** ‚Äì character vector of g:Profiler organism codes.\
-   **`orgdb`** ‚Äì OrgDb package used for GO structure and semantic similarity (e.g. `"org.Mm.eg.db"`).\
-   **`outdir`** ‚Äì where to save all results.\
-   **`make_report`** ‚Äì if `TRUE`, generates an interactive HTML report (Rmarkdown).

### Under the hood

`run_full_echogo()` orchestrates:

1.  **GOseq enrichment** (bias-corrected via gene length) if requested and inputs are available\
2.  **g:Profiler with custom background** (robust cross-species enrichment)\
3.  **g:Profiler genome-wide** (exploratory, no background)\
4.  **Consensus scoring** (via `score_consensus_terms()`)\
5.  **RRvGO reduction** (clusters semantically similar terms)\
6.  **Network analysis** (gene-overlap GO term networks)\
7.  **Report generation** (if `make_report = TRUE`)

------------------------------------------------------------------------

# Understanding the output structure

After running, your `outdir` contains a set of subfolders. For the demo snapshot:

```{r explore_outputs}
# See what's in the frozen demo results
list.files(demo_out, recursive = TRUE, max.depth = 2)
```

## Directory guide

### `consensus/`

**Start here.** Contains annotated consensus tables and curated plots.

-   `consensus_enrichment_results_with_and_without_bg.xlsx` ‚Äì main results table\
-   `plots_strict/` ‚Äì visualizations using strict consensus (`consensus_score`)\
-   `plots_exploratory/` ‚Äì visualizations using exploratory consensus (`consensus_score_all`)

### `diagnostics/` & `evaluation/`

Quality control and diagnostic plots:

-   `EQI_distribution_by_ontology.png` ‚Äì term agreement quality\
-   `FoldEnrichment_distribution_by_ontology.png` ‚Äì enrichment magnitude\
-   `rarefaction_curve_by_origin_*.png` ‚Äì saturation curves (methods/species)

### `goseq/`

Bias-aware GOseq enrichment results:

-   `GOseq_enrichment_full_annotated.csv` ‚Äì full GOseq output with annotations

### `gprofiler/`

Raw g:Profiler results (one folder per species or background mode):

-   `with_custom_background/` ‚Äì conservative, background-corrected results\
-   `no_background_genome_wide/` ‚Äì exploratory, genome-wide results

### `rrvgo/`

Semantic similarity reduction (per ontology BP/MF/CC):

-   `rrvgo_true_consensus_with_bg/` ‚Äì strict consensus clusters\
-   `rrvgo_exploratory_all_significant/` ‚Äì all significant terms clustered

These folders typically contain:

-   Treemaps, bubble plots, heatmaps, wordclouds\
-   Cluster summary tables\
-   Representative term lists per cluster

### `networks/`

GO term overlap networks:

-   `with_bg/` ‚Äì strict consensus networks\
-   `with_bg_and_nobg/` ‚Äì exploratory networks

Each contains networks for BP, MF, and CC (static PDF/SVG + interactive HTML).

### `report/`

Interactive HTML report (if `make_report = TRUE`):

-   `EchoGO_report.html` or `index.html` ‚Äì browse-friendly summary of all results

For a **deep dive** into what each file means and how the consensus scores are built, see `vignette("EchoGO_interpretation")`.

------------------------------------------------------------------------

# Peeking at results

## Load the main consensus table

```{r peek_consensus}
consensus_file <- file.path(
  demo_out, "consensus",
  "consensus_enrichment_results_with_and_without_bg.xlsx"
)

stopifnot(file.exists(consensus_file))

cons <- read_xlsx(consensus_file)

# View key columns
head(cons[, c(
  "term_id", "term_name", "ontology",
  "consensus_score", "consensus_score_all",
  "source_origin", "significant_in_any"
)])
```

### What these columns mean (briefly)

-   **`term_id`** ‚Äì GO or KEGG identifier (e.g., `"GO:0006355"`)\
-   **`term_name`** ‚Äì human-readable name\
-   **`ontology`** ‚Äì BP (Biological Process), MF (Molecular Function), or CC (Cellular Component)\
-   **`consensus_score`** ‚Äì strict consensus score (conservative)\
-   **`consensus_score_all`** ‚Äì exploratory score (includes genome-wide g:Profiler)\
-   **`source_origin`** ‚Äì combination of sources (GOseq, g:Profiler with/without background)\
-   **`significant_in_any`** ‚Äì `TRUE` if any method supports the term

For full details and biological interpretation, see `vignette("EchoGO_interpretation")`.

## Peek at GOseq results

```{r peek_goseq}
goseq_file <- file.path(demo_out, "goseq", "GOseq_enrichment_full_annotated.csv")
if (file.exists(goseq_file)) {
  goseq <- read.csv(goseq_file)
  head(goseq[, intersect(c("category","term","ontology","numDEInCat","numInCat","foldEnrichment","over_represented_FDR"), names(goseq))])
}
```

*(Column names in your GOseq file may vary slightly; adjust as needed.)*

## Peek at g:Profiler results

```{r peek_gprofiler}
# Results are stored per species and background mode
gprofiler_dir <- file.path(demo_out, "gprofiler")
list.files(gprofiler_dir, recursive = TRUE)
```

------------------------------------------------------------------------

# Working example: exploring demo results

## Load and filter consensus results

```{r example_load}
consensus_file <- file.path(
  demo_out, "consensus",
  "consensus_enrichment_results_with_and_without_bg.xlsx"
)
cons <- read_xlsx(consensus_file)

top_terms <- cons %>%
  dplyr::filter(significant_in_any) %>%
  dplyr::arrange(dplyr::desc(consensus_score_all)) %>%
  dplyr::slice(1:20)

# Show key columns
top_terms %>%
  dplyr::select(
    term_name, ontology,
    consensus_score, consensus_score_all,
    source_origin
  ) %>%
  head(10)
```

## Quick visualization

```{r example_plot, fig.width=8, fig.height=5}
library(ggplot2)
library(stringr)

plot_df <- cons %>%
  dplyr::filter(significant_in_any, !is.na(consensus_score_all)) %>%
  dplyr::slice_max(consensus_score_all, n = 15, with_ties = FALSE) %>%
  dplyr::arrange(consensus_score_all) %>%
  dplyr::mutate(
    term_label = stringr::str_trunc(
      paste0(term_name, " (", term_id, ")"),
      45
    ),
    term_label = factor(term_label, levels = term_label)
  )

ggplot(plot_df, aes(
  y     = term_label,
  x     = consensus_score_all,
  color = ontology
)) +
  geom_segment(aes(
    yend = term_label,
    xend = 0
  ),
  linewidth = 0.6,
  color     = "grey70"
  ) +
  geom_point(size = 3) +
  scale_color_brewer(palette = "Dark2", name = "Ontology") +
  labs(
    x     = "Exploratory consensus score",
    y     = NULL,
    title = "Top 15 EchoGO terms by exploratory consensus"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    axis.text.y     = element_text(size = 9),
    legend.position = "bottom",
    plot.title      = element_text(hjust = 0.5, size = 12)
  )
```

------------------------------------------------------------------------

# Workflow checklist

Before running your analysis:

-   [ ] Install required OrgDb package: `echogo_install_orgdb()`\
-   [ ] Choose species: `echogo_pick_species()` or check the g:Profiler organism list\
-   [ ] Validate species codes: `echogo_preflight_species()`\
-   [ ] Create a project scaffold: `echogo_scaffold("my_project")`\
-   [ ] Prepare inputs in `my_project/input` (see `_README.txt`)\
-   [ ] Set defaults if needed: `options(EchoGO.default_orgdb = ...)`

Run:

-   [ ] Run the pipeline: `echogo_run()` or `run_full_echogo(...)`

After running:

-   [ ] Check `consensus_enrichment_results_with_and_without_bg.xlsx`\
-   [ ] Inspect diagnostics (`diagnostics/`, `evaluation/`)\
-   [ ] Explore RRvGO clusters (`rrvgo/`)\
-   [ ] View networks (`networks/`)\
-   [ ] Open HTML report (`report/`) if generated

------------------------------------------------------------------------

# Detailed parameter reference

## `run_full_echogo()` parameters

```{r, eval=FALSE}
run_full_echogo(
  input_dir = NULL,
  goseq_file = NULL,
  trinotate_file = NULL,
  de_file = NULL,
  count_matrix_file = NULL,
  species = getOption("EchoGO.default_species", c("hsapiens","mmusculus","drerio")),
  species_expr = NULL,
  orgdb   = getOption("EchoGO.default_orgdb", "org.Dr.eg.db"),
  outdir  = "echogo_out",
  make_report = TRUE,
  report_sections = c("overview","goseq","gprofiler","consensus","rrvgo","networks"),
  report_top_n = 25,
  report_theme = "flatly",
  report_template = NULL,
  strict_only = FALSE,
  run_evaluation = TRUE,
  use_trinotate_universe = FALSE,
  verbose = TRUE
)
```

## `echogo_preflight_species()` parameters

```{r, eval=FALSE}
echogo_preflight_species(
  species = NULL,               # Character vector of organism codes
  suggest = TRUE                # Suggest corrections for invalid codes?
)
```

------------------------------------------------------------------------

# Troubleshooting

## OrgDb not found

``` text
Error: OrgDb 'org.Mm.eg.db' not installed
```

**Solution:**

```{r, eval=FALSE}
echogo_install_orgdb("org.Mm.eg.db")
echogo_require_orgdb("org.Mm.eg.db")
```

## Species code not recognized

``` text
Warning: Species 'human' not recognized
```

**Solution:** Use the interactive picker or check the full list at\
<https://biit.cs.ut.ee/gprofiler/page/organism-list>

```{r, eval=FALSE}
echogo_preflight_species("hsapiens")  # Use proper code, not common name
```

## g:Profiler timeout

If you have a very large species list or gene set, g:Profiler may time out. Try:

-   Reducing the number of species\
-   Splitting your gene list into smaller subsets\
-   Increasing timeout, e.g.:

```{r, eval=FALSE}
options(EchoGO.gprofiler_timeout = 120)
```

------------------------------------------------------------------------

# Next steps

1.  **Explore the demo:**\
    Run `echogo_quickstart(run_demo = TRUE)` and browse the outputs under `echogo_demo_results_path()`.

2.  **Prepare your data:**\
    Create a project with `echogo_scaffold("my_project")` and follow the `_README.txt` instructions.

3.  **Run your analysis:**\
    Use `echogo_run()` or `run_full_echogo(...)` with your own inputs.

4.  **Interpret results:**\
    See `vignette("EchoGO_interpretation")` for detailed guidance on reading outputs, understanding consensus scores, RRvGO clusters, and building networks into mechanistic stories.

------------------------------------------------------------------------

# Citation

If you use EchoGO in your research, please cite:

> Escobar-Sierra C., Inostroza P.A., *et al.* (2025). EchoGO: Cross-species functional enrichment analysis. *Journal*, Volume, Pages.

------------------------------------------------------------------------

# R session
```{r session-info, echo=FALSE}
sessionInfo()
```

